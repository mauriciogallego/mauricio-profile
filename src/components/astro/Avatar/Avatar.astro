<script>
  import * as THREE from 'three';
  import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
  import { gsap } from 'gsap';

  const avatar = document.getElementById('avatar-animation');
  const width = window.innerWidth / 4;
  const height = window.innerHeight / 1.5;

  console.log({ width, height });
  if (!avatar) {
    throw new Error();
  }
  // Initialize Renderer
  const renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.outputColorSpace = THREE.SRGBColorSpace;
  renderer.setSize(width, height);
  renderer.setClearColor(0xfffff, 0); // Light gray background
  renderer.shadowMap.enabled = true;
  renderer.shadowMap.type = THREE.PCFSoftShadowMap;
  renderer.toneMapping = THREE.ACESFilmicToneMapping; // Apply Linear tone mapping
  renderer.toneMappingExposure = 1.9; // Adjust exposure

  avatar.appendChild(renderer.domElement);

  // Initialize Scene
  const scene = new THREE.Scene();

  // Initialize Camera
  const camera = new THREE.PerspectiveCamera(75, width / height, 1, 1000);

  camera.position.set(1, 4.9, 11);
  camera.lookAt(-2, 0, 0);
  scene.add(camera);

  // SpotLight for focused lighting
  const spotLight = new THREE.SpotLight(0xffffff, 1.5);
  spotLight.position.set(10, 15, 10);
  spotLight.castShadow = true;
  spotLight.shadow.radius = 4;
  spotLight.shadow.mapSize.set(2048, 2048);
  scene.add(spotLight);

  // Bright ambient light for overall illumination
  const ambientLight = new THREE.AmbientLight(0xffffff, 0.3);
  scene.add(ambientLight);

  // Add a key light (main light source)
  const keyLight = new THREE.DirectionalLight(0xffffff, 1.0);
  keyLight.shadow.mapSize.width = 2048;
  keyLight.intensity = 1.2; // Brighter key light
  keyLight.shadow.mapSize.height = 2048;
  keyLight.shadow.radius = 8;
  keyLight.position.set(10, 10, 10);
  keyLight.castShadow = true;
  scene.add(keyLight);

  // Add a fill light (softens shadows)
  const fillLight = new THREE.DirectionalLight(0xffffff, 0.5);
  fillLight.position.set(-10, 5, 5);
  fillLight.intensity = 0.6; // Balanced fill light
  scene.add(fillLight);

  // Add a back light (adds depth)
  const backLight = new THREE.DirectionalLight(0xffffff, 0.3);
  backLight.position.set(0, 10, -10);
  scene.add(backLight);

  const hemisphereLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.5); // Adjust intensity as needed
  hemisphereLight.position.set(0, 20, 0);
  scene.add(hemisphereLight);

  const lightProbe = new THREE.LightProbe();
  lightProbe.intensity = 0.5;
  scene.add(lightProbe);

  const specularLight = new THREE.SpotLight(0xffffff, 0.3);
  specularLight.position.set(5, 10, 5);
  scene.add(specularLight);

  // Load GLTF Model
  const loader = new GLTFLoader();
  let bones = new Map();

  loader.setPath('/avatar/');
  loader.load(
    'avatar_mauricio.glb',
    (gltf) => {
      const mesh = gltf.scene;
      mesh.position.set(1, -3.05, 4);
      mesh.scale.setScalar(5);

      // Traverse to populate bones map and enable shadows
      mesh.traverse((node: any) => {
        if (node.isBone) {
          const bone = node as THREE.Bone;

          bones.set(bone.name, bone); // Add bones to the map
          // putting in the right position (Right)
          if (bone.name === 'RightForeArm') {
            bone.rotation.x = Math.PI / 5;
            bone.rotation.z = -Math.PI / 6;
          }

          // putting in the right position (Left)
          if (bone.name === 'LeftArm') {
            bone.rotation.x = Math.PI / 2.5;
            bone.rotation.y = Math.PI / 6;
          }
          if (bone.name === 'LeftForeArm') {
            bone.rotation.x = Math.PI / 5;
          }
        }

        if (node.isMesh) {
          node.castShadow = true;
          node.receiveShadow = true;
        }

        const material = node.material;
        if (material && material.isMeshStandardMaterial) {
          material.metalness = 0.1; // Slight metallic look
          material.roughness = 0.5; // Semi-smooth surface
          material.envMapIntensity = 1.0; // Reflective lighting intensity
        }
      });

      scene.add(mesh);

      animateSayHello();
    },
    function (xhr) {
      console.log((xhr.loaded / xhr.total) * 100 + '% loaded');
    },
    function (error) {
      console.error(error);
      console.error('An error occurred while loading the model.');
    },
  );

  // Handle Window Resizing
  window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });

  function animateSayHello() {
    if (bones.size > 0) {
      // Get the bones for the arm and forearm
      const rightArmBone = bones.get('RightArm');
      const rightForeArmBone = bones.get('RightForeArm'); // Corrected name
      const rightHand = bones.get('RightHand'); // Corrected name

      if (rightArmBone && rightForeArmBone) {
        // Animate the RightArm to raise

        gsap.to(rightArmBone.rotation, {
          x: Math.PI / 5, // Raise RightArm slightly
          ease: 'power2.in',
          onComplete: () => {
            gsap.to(rightForeArmBone.rotation, {
              x: -Math.PI / 2,
              ease: 'power2.out',
              onStart: () => {
                gsap.to(rightArmBone.rotation, {
                  x: Math.PI / 3, // Raise RightArm slightly
                  ease: 'power2.out',
                });
              },
            });
          },
        });

        gsap.to(rightForeArmBone.rotation, {
          y: Math.PI / 3,
          duration: 1,
          ease: 'power2.out',
          delay: 1,
        });

        gsap.to(rightForeArmBone.rotation, {
          z: -Math.PI / 3,
          yoyo: true,
          repeat: 4, // Infinite loop
          duration: 1,
          ease: 'sine.inOut',
          delay: 1.5,
        });

        gsap.to(rightHand.rotation, {
          z: 0.5, // Rotate hand
          duration: 1.9,
          yoyo: true,
          repeat: 4, // Infinite loop
          ease: 'sine.inOut',
        });
      }

      const torsoBone = bones.get('Spine2');
      const headBone = bones.get('Head');

      if (torsoBone && headBone) {
        gsap.to(torsoBone.rotation, {
          y: Math.PI / 18, // Slight body twist
          duration: 1.5,
          yoyo: true,
          repeat: 4,
          ease: 'sine.inOut',
        });
      }

      if (headBone) {
        gsap.to(headBone.rotation, {
          y: -Math.PI / 12, // Slight head tilt
          duration: 1.5,
          yoyo: true,
          repeat: 4,
          ease: 'sine.inOut',
        });
      }
    }
  }
  function animate() {
    requestAnimationFrame(animate);
    renderer.render(scene, camera);
  }
  animate();
</script>

<div id="avatar-animation"></div>
